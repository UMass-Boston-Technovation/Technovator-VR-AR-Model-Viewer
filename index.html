<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR/VR Model Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Silence favicon 404s -->
  <link rel="icon" href="data:," />

  <!-- Babylon core + loaders + GUI (GUI optional) -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #111; color: #eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; display: block; }

    .note {
      position: absolute; left: 12px; top: 12px; z-index: 2;
      background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 8px; backdrop-filter: blur(6px);
      font-size: 14px; line-height: 1.35; max-width: min(420px, 85vw);
    }
    .row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .btn {
      appearance: none; border: 1px solid #444; background: #1d1d1d; color: #eee;
      padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 600;
    }
    .btn[disabled] { opacity: 0.45; cursor: not-allowed; }
    .muted { opacity: 0.8; }
    code { background: #222; padding: 1px 4px; border-radius: 4px; }
    a { color: #9ad; }
  </style>
</head>
<body>
  <div class="note">
    <div><strong>UMB Technovator Model Viewer</strong></div>
    <div class="muted">Note: Browser must support WebXR for VR button to activate.</div>
    <div class="row">
      <button id="enter-vr" class="btn" disabled>Enter VR</button>
      <button id="enter-ar" class="btn" disabled>Enter AR</button>
    </div>
  </div>

  <canvas id="renderCanvas"></canvas>

  <!-- THIS SECTION CONTAINS THE ENGINE OF THE MODEL VIEWING CODE -->
  <script>
      // ---- Asset selection ----
    const MODEL_PATH = "./3D_Models/"; // e.g., "./3D_Models/"
    const MODEL_FILE = "maxwell3D.glb";  // (case-sensitive on many hosts))

    async function createScene(engine, canvas) {
      const scene = new BABYLON.Scene(engine);
      scene.createDefaultEnvironment({ createSkybox: false });

      // Camera
      const camera = new BABYLON.ArcRotateCamera("camera",
        Math.PI / 2, Math.PI / 3, 5,
        BABYLON.Vector3.Zero(), scene
      );
      camera.attachControl(canvas, true);
      camera.lowerRadiusLimit = 0.25;

      // Light
      new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);

      // Optional test geometry (uncomment to sanity-check rendering)
      // BABYLON.MeshBuilder.CreateBox("box", { size: 0.5 }, scene);

      // ---- Load model ----
      const result = await BABYLON.SceneLoader.ImportMeshAsync("", MODEL_PATH, MODEL_FILE, scene);

      // Optionally parent imported meshes under a TransformNode (not required)
      const root = new BABYLON.TransformNode("root", scene);
      for (const m of result.meshes) {
        // Keep the sceneLoader's "__root__" free; parent all other top-level meshes for organization
        if (m.name !== "__root__" && !m.parent) m.setParent(root);
      }

      // ---- Safe framing: compute bounds from solid meshes ----
      const solidMeshes = result.meshes.filter(m =>
        m instanceof BABYLON.Mesh && m.getTotalVertices && m.getTotalVertices() > 0
      );

      if (solidMeshes.length) {
        const minMax = BABYLON.Mesh.MinMax(solidMeshes);
        const center = minMax.min.add(minMax.max).scale(0.5);
        const extent = minMax.max.subtract(minMax.min).length();

        camera.setTarget(center);
        camera.radius = Math.max(2.5, extent * 0.9);

        // Optional: gently lift the target if the model sits on Y=0
        if (center.y < 0.1 && minMax.max.y > 0.1) {
          camera.target = new BABYLON.Vector3(center.x, Math.min(0.5, minMax.max.y * 0.25), center.z);
        }
      } else {
        // Fallback framing when nothing solid imported
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.radius = 5;
      }

      // Optional: enable built-in framing behavior too (nice for arc camera)
      camera.useFramingBehavior = true;

      return scene;
    }

    // ---- XR wiring (optional & graceful) ----
    async function setupXR(scene, engine) {
      const btnVR = document.getElementById("enter-vr");
      const btnAR = document.getElementById("enter-ar");

      // WebXR typically requires HTTPS or http://localhost. If unsupported, keep buttons disabled.
      const xrAvailable = "xr" in navigator;
      let xr = null;

      if (xrAvailable) {
        // Probe support
        const arSupported = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-ar");
        const vrSupported = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-vr");

        // Enable buttons only when supported
        if (vrSupported) btnVR.disabled = false;
        if (arSupported) btnAR.disabled = false;

        // Create one default experience (can start VR or AR sessions)
        xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
          floorMeshes: [],
          uiOptions: {
            sessionMode: "immersive-vr"
          },
          optionalFeatures: [
            "local-floor",
            "bounded-floor",
            "hand-tracking",
            "anchors",
            "hit-test",
            "plane-detection",
            "dom-overlay"
          ],
          requiredFeatures: ["local-floor"], // needed for Quest VR
          domOverlay: { root: document.body }
        });


        // Enable optional AR helpers (will silently no-op if unsupported)
        const fm = xr.baseExperience.featuresManager;
        fm.enableFeature(BABYLON.WebXRHitTest.Name, "latest", { transientHitTest: true });
        fm.enableFeature(BABYLON.WebXRPlaneDetector.Name, "latest");
        fm.enableFeature(BABYLON.WebXRAnchorSystem.Name, "latest");
        fm.enableFeature(BABYLON.WebXRHandTracking.Name, "latest");

        // Optional: simple AR reticle that appears when hit-test finds a surface
        const reticle = BABYLON.MeshBuilder.CreateTorus("reticle", { thickness: 0.003, diameter: 0.08 }, scene);
        reticle.isPickable = false; reticle.setEnabled(false);

        const hitFeature = fm.getEnabledFeatures().find(f => f.name === BABYLON.WebXRHitTest.Name);
        if (hitFeature) {
          hitFeature.onHitTestResultObservable.add(results => {
            const r = results && results[0];
            if (r) {
              reticle.setEnabled(true);
              reticle.position.copyFrom(r.position);
              if (r.rotationQuaternion) reticle.rotationQuaternion = r.rotationQuaternion.clone();
            } else {
              reticle.setEnabled(false);
            }
          });
        }

        // Button handlers
        btnVR.addEventListener("click", async () => {
          if (btnVR.disabled) return;
          await xr.baseExperience.enterXRAsync("immersive-vr", "local-floor");
        });

        btnAR.addEventListener("click", async () => {
        if (btnAR.disabled) return;
        await xr.baseExperience.enterXRAsync("immersive-ar", "local", {
          requiredFeatures: ["hit-test"],
          optionalFeatures: ["dom-overlay", "plane-detection"],
          domOverlay: { root: document.body }
        });
      });
      }
      // If no WebXR, keep normal 3D view; buttons stay disabled as a hint
      return xr;
    }

    // ---- Bootstrap engine/scene ----
    (async function main() {
      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

      const scene = await createScene(engine, canvas);
      await setupXR(scene, engine);

      engine.runRenderLoop(() => scene.render());
      window.addEventListener("resize", () => engine.resize());
    })();
  </script>
<!-- THIS SECTION CONTAINS THE ENGINE OF THE MODEL VIEWING CODE -->

</body>
</html>
