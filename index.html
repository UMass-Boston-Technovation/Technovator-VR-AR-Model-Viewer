<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>AR/VR Model Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Silence favicon 404s -->
  <link rel="icon" href="data:," />

  <!-- Babylon core + loaders + GUI (GUI optional) -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>



  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #111; color: #eee; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #renderCanvas { width: 100%; height: 100%; touch-action: none; display: block; }

    .note {
      position: absolute; left: 12px; top: 12px; z-index: 2;
      background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 8px; backdrop-filter: blur(6px);
      font-size: 14px; line-height: 1.35; max-width: min(420px, 85vw);
    }
    .row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .btn {
      appearance: none; border: 1px solid #444; background: #1d1d1d; color: #eee;
      padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 600;
    }
    .btn[disabled] { opacity: 0.45; cursor: not-allowed; }
    .muted { opacity: 0.8; }
    code { background: #222; padding: 1px 4px; border-radius: 4px; }
    a { color: #9ad; }
  </style>
</head>
<body>
  <div class="note">
    <div><strong>UMB Technovator Model Viewer</strong></div>
    <div class="muted">Note: Browser must support WebXR for AR/VR buttons to activate.</div>
    <div class="row">
      <button id="enter-vr" class="btn" disabled>Enter VR</button>
      <button id="enter-ar" class="btn" disabled>Enter AR</button>
      <select id="model-select" class="btn" onchange="loadNewModel(this.value)">
        <option disabled selected value="">SELECT A MODEL</option>
        <option value="maxwell3D.glb">Maxwell</option>
        <option value="RangeRover.glb">Range Rover</option> <!-- Range Rover by IvOfficial [CC-BY] via Poly Pizza -->
      </select>
      <button id="upload-model" class="btn">+</button>
    </div>
  </div>

  <canvas id="renderCanvas"></canvas>

  <script>
    // ---- Asset selection ----
    const MODEL_PATH = "./3D_Models/";
    let engine = null;
    let currentScene = null;

    // Create and configure a scene with the specified model
    async function createScene(engine, canvas, modelFile = "maxwell3D.glb") {
      const scene = new BABYLON.Scene(engine);
      scene.createDefaultEnvironment({ createSkybox: false });

      // Camera setup
      const camera = new BABYLON.ArcRotateCamera("camera",
        Math.PI / 2, Math.PI / 3, 5,
        BABYLON.Vector3.Zero(), scene
      );
      camera.attachControl(canvas, true);
      camera.lowerRadiusLimit = 0.25;
      new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);

      // Load model
      const result = await BABYLON.SceneLoader.ImportMeshAsync("", MODEL_PATH, modelFile, scene);

      // Parent meshes neatly
      const root = new BABYLON.TransformNode("root", scene);
      for (const m of result.meshes) {
        if (m.name !== "__root__" && !m.parent) m.setParent(root);
      }

      // Frame the camera to the model
      const solidMeshes = result.meshes.filter(m =>
        m instanceof BABYLON.Mesh && m.getTotalVertices && m.getTotalVertices() > 0
      );

      if (solidMeshes.length) {
        const minMax = BABYLON.Mesh.MinMax(solidMeshes);
        const center = minMax.min.add(minMax.max).scale(0.5);
        const extent = minMax.max.subtract(minMax.min).length();

        camera.setTarget(center);
        camera.radius = Math.max(2.5, extent * 0.9);

        if (center.y < 0.1 && minMax.max.y > 0.1) {
          camera.target = new BABYLON.Vector3(center.x, Math.min(0.5, minMax.max.y * 0.25), center.z);
        }
      } else {
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.radius = 5;
      }

      camera.useFramingBehavior = true;
      return scene;
    }

    // XR setup
    async function setupXR(scene, engine) {
      const btnVR = document.getElementById("enter-vr");
      const btnAR = document.getElementById("enter-ar");

      if (!("xr" in navigator)) {
        console.warn("WebXR not supported in this browser â€” running in standard 3D mode.");
        return null;
      }

      try {
        const arSupported = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-ar");
        const vrSupported = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-vr");

        if (vrSupported) btnVR.disabled = false;
        if (arSupported) btnAR.disabled = false;

        const xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
          floorMeshes: [],
          optionalFeatures: ["local-floor", "bounded-floor", "hit-test", "anchors", "plane-detection", "hand-tracking"]
        });

        // Enter VR (safe)
        btnVR.addEventListener("click", async () => {
          if (btnVR.disabled) return;
          await xr.baseExperience.enterXRAsync("immersive-vr", "local-floor");
        });

        // Enter AR (with AR-only features)
        btnAR.addEventListener("click", async () => {
          if (btnAR.disabled) return;
          const arExperience = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
            optionalFeatures: ["hit-test", "plane-detection"],
            domOverlay: { root: document.body }
          });
          await arExperience.baseExperience.enterXRAsync("immersive-ar", "local", {
            requiredFeatures: ["hit-test"],
            optionalFeatures: ["dom-overlay", "plane-detection"]
          });
        });

        return xr;
      } catch (err) {
        console.warn("WebXR initialization failed:", err);
        return null;
      }
    }

    // Handle model change from dropdown
    async function loadNewModel(modelFile) {
      if (!engine) return;
      engine.stopRenderLoop();
      if (currentScene) {
        currentScene.dispose();
      }
      currentScene = await createScene(engine, document.getElementById("renderCanvas"), modelFile);
      await setupXR(currentScene, engine);
      engine.runRenderLoop(() => currentScene.render());
    }

    // ===== HANDLE MODEL UPLOAD =====
    const uploadBtn = document.getElementById("upload-model");

    uploadBtn.addEventListener("click", async () => {
      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".glb,.gltf,.obj,.fbx";

      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = async () => {
          const base64Data = reader.result.split(",")[1];
          const filename = file.name;

          const repoOwner = prompt("Enter GitHub username (repo owner):");
          const repoName = prompt("Enter repository name:");
          const token = prompt("Enter GitHub Personal Access Token (only needs 'repo:contents' scope):");

          if (!repoOwner || !repoName || !token) {
            alert("Upload cancelled: missing required information.");
            return;
          }

          const apiUrl = `https://api.github.com/repos/${repoOwner}/${repoName}/contents/3D_Models/${filename}`;

          try {
            const existingFile = await fetch(apiUrl, {
              headers: { Authorization: `token ${token}` }
            });
            const exists = existingFile.status === 200;
            let sha = null;
            if (exists) {
              const data = await existingFile.json();
              sha = data.sha;
              if (!confirm(`File ${filename} exists. Overwrite it?`)) return;
            }

            const response = await fetch(apiUrl, {
              method: "PUT",
              headers: {
                "Authorization": `token ${token}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                message: `Upload ${filename} via AR/VR Model Viewer`,
                content: base64Data,
                sha: sha || undefined
              })
            });

            if (response.ok) {
              alert(`Uploaded ${filename} successfully!`);
              const select = document.getElementById("model-select");
              const option = document.createElement("option");
              option.value = filename;
              option.textContent = filename.replace(/\.[^/.]+$/, "");
              select.appendChild(option);
            } else {
              const err = await response.json();
              alert(`Upload failed: ${err.message}`);
            }
          } catch (error) {
            console.error(error);
            alert("Upload failed: " + error.message);
          }
        };
        reader.readAsDataURL(file);
      };
      input.click();
    });

    // Bootstrap the viewer
    (async function main() {
      const canvas = document.getElementById("renderCanvas");
      engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });
      currentScene = await createScene(engine, canvas);
      await setupXR(currentScene, engine);
      engine.runRenderLoop(() => currentScene.render());
      window.addEventListener("resize", () => engine.resize());
    })();
  </script>
</body>
</html>
