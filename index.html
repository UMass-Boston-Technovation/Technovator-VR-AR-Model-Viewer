<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Technovator AR/VR Model Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:," />
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

  <style>
    html, body {
      height: 100%; margin: 0; overflow: hidden;
      background: #111; color: #eee;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    #renderCanvas { width: 100%; height: 100%; display: block; }
    .note {
      position: absolute; left: 12px; top: 12px; z-index: 2;
      background: rgba(0,0,0,0.55); padding: 10px 12px; border-radius: 8px;
      font-size: 14px; line-height: 1.35; max-width: min(420px, 85vw);
    }
    .row { display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap; }
    .btn {
      appearance: none; border: 1px solid #444; background: #1d1d1d; color: #eee;
      padding: 8px 12px; border-radius: 6px; cursor: pointer; font-weight: 600;
    }
    .btn[disabled] { opacity: 0.45; cursor: not-allowed; }
    input, select { border: 1px solid #333; background: #222; color: #eee; padding: 6px; border-radius: 4px; }
    .auth-box {
      position: absolute; bottom: 20px; left: 20px; background: rgba(0,0,0,0.5);
      padding: 10px; border-radius: 6px;
    }
  </style>
</head>
<body>
  <div class="note">
    <div><strong>Technovator AR/VR Model Viewer</strong></div>
    <div class="muted">Login to upload and view your 3D models.</div>
    <div class="row">
      <button id="enter-vr" class="btn" disabled>Enter VR</button>
      <button id="enter-ar" class="btn" disabled>Enter AR</button>
      <select id="model-select" class="btn">
        <option disabled selected value="">SELECT A MODEL</option>
      </select>
      <button id="upload-model" class="btn" disabled>+</button>
      <button id="logout-btn" class="btn" style="display:none;">Logout</button>
    </div>
  </div>

  <div class="auth-box" id="auth-box">
    <input type="email" id="email" placeholder="Email" />
    <input type="password" id="password" placeholder="Password" />
    <button id="login-btn" class="btn">Login / Sign Up</button>
  </div>

  <canvas id="renderCanvas"></canvas>

  <script>
    // ==============================
    //  SUPABASE CONFIGURATION
    // ==============================
    const SUPABASE_URL = "https://cdlnlhdeslmdzwbkskqc.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable_i5h1CPV7RNrK13PSV9ADxw_wZtD1l8z";
    const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const BUCKET = "models";

    // ==============================
    //  BABYLON.JS SETUP
    // ==============================
    let engine, currentScene;
    const canvas = document.getElementById("renderCanvas");

    async function createScene(engine, canvas, modelUrl = null) {
      const scene = new BABYLON.Scene(engine);
      scene.createDefaultEnvironment({ createSkybox: false });
      const camera = new BABYLON.ArcRotateCamera("camera",
        Math.PI / 2, Math.PI / 3, 5, BABYLON.Vector3.Zero(), scene
      );
      camera.attachControl(canvas, true);
      new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);

      if (modelUrl) {
        await BABYLON.SceneLoader.ImportMeshAsync("", modelUrl, "", scene);
      }
      return scene;
    }

    async function setupXR(scene) {
      const btnVR = document.getElementById("enter-vr");
      const btnAR = document.getElementById("enter-ar");
      if (!("xr" in navigator)) return;

      const arSupported = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-ar");
      const vrSupported = await BABYLON.WebXRSessionManager.IsSessionSupportedAsync("immersive-vr");
      if (vrSupported) btnVR.disabled = false;
      if (arSupported) btnAR.disabled = false;

      const xr = await BABYLON.WebXRDefaultExperience.CreateAsync(scene, {
        optionalFeatures: ["local-floor", "bounded-floor"]
      });
      // Enable pointer selection and near interaction features
      try {
        const fm = xr.baseExperience.featuresManager;
        fm.enableFeature(BABYLON.WebXRFeatureName.POINTER_SELECTION, "latest");
        fm.enableFeature(BABYLON.WebXRFeatureName.NEAR_INTERACTION, "latest");

        // Controller state for grab/scale
        const controllers = {};

        xr.input.onControllerAddedObservable.add((xrController) => {
          const id = xrController.uniqueId || String(Date.now());
          controllers[id] = { xrController, grabbedMesh: null, origParent: null, origScaling: null };

          xrController.onMotionControllerInitObservable && xrController.onMotionControllerInitObservable.add((motionController) => {
            let trigger = motionController.getComponent && motionController.getComponent("trigger");
            if (!trigger && motionController.getComponent) {
              trigger = motionController.getComponent("xr-standard-trigger") || trigger;
            }
            if (!trigger) return;

            trigger.onButtonStateChangedObservable.add(() => {
              const state = trigger.pressed;
              const s = controllers[id];
              if (state) {
                // try pick with forward ray
                const forwardRay = (xrController.pointer && xrController.pointer.getForwardRay && xrController.pointer.getForwardRay()) || (xrController.getForwardRay && xrController.getForwardRay());
                if (!forwardRay) return;
                const pick = scene.pickWithRay(forwardRay);
                if (pick && pick.hit && pick.pickedMesh) {
                  const mesh = pick.pickedMesh;
                  s.grabbedMesh = mesh;
                  s.origParent = mesh.parent;
                  s.origScaling = mesh.scaling && mesh.scaling.clone ? mesh.scaling.clone() : new BABYLON.Vector3(1,1,1);
                  // Attach mesh to controller grip (or pointer) so it follows rotation/position
                  try { mesh.setParent(xrController.grip || xrController.pointer || xrController); } catch(e) { mesh.parent = xrController.grip || xrController.pointer || null; }
                }
              } else {
                // release
                if (s && s.grabbedMesh) {
                  try { s.grabbedMesh.setParent(s.origParent || null); } catch(e) { s.grabbedMesh.parent = s.origParent || null; }
                  s.grabbedMesh = null;
                  s.origParent = null;
                }
              }
            });
          });
        });

        // Two-hand scaling helper
        function updateTwoHandScaling() {
          const held = Object.values(controllers).filter(c => c.grabbedMesh);
          if (held.length === 2 && held[0].grabbedMesh === held[1].grabbedMesh) {
            const mc = held[0].grabbedMesh;
            const g0 = held[0].xrController.grip || held[0].xrController.pointer;
            const g1 = held[1].xrController.grip || held[1].xrController.pointer;
            if (!g0 || !g1) return;
            const p0 = g0.position || BABYLON.Vector3.Zero();
            const p1 = g1.position || BABYLON.Vector3.Zero();
            const curDist = BABYLON.Vector3.Distance(p0, p1);
            if (!mc._twoHand) {
              mc._twoHand = { initialDistance: curDist || 1, initialScale: mc.scaling && mc.scaling.clone ? mc.scaling.clone() : new BABYLON.Vector3(1,1,1) };
            }
            const scaleFactor = (mc._twoHand.initialDistance > 0) ? (curDist / mc._twoHand.initialDistance) : 1;
            mc.scaling = mc._twoHand.initialScale.scale(scaleFactor);
          } else {
            // clear two-hand state when not holding with two controllers
            Object.values(controllers).forEach(c => { if (c.grabbedMesh && c.grabbedMesh._twoHand) c.grabbedMesh._twoHand = null; });
          }
        }

        scene.onBeforeRenderObservable.add(() => updateTwoHandScaling());
      } catch (e) {
        console.warn('XR interaction features not available:', e);
      }
      btnVR.onclick = async () => xr.baseExperience.enterXRAsync("immersive-vr", "local-floor");
      btnAR.onclick = async () => xr.baseExperience.enterXRAsync("immersive-ar", "local");
    }

    // ==============================
    //  SUPABASE AUTH + STORAGE
    // ==============================

    async function checkUser() {
      const { data: { user } } = await supabaseClient.auth.getUser();
      if (user) {
        document.getElementById("auth-box").style.display = "none";
        document.getElementById("upload-model").disabled = false;
        document.getElementById("logout-btn").style.display = "inline-block";
        await loadModelList(user);
      } else {
        document.getElementById("auth-box").style.display = "block";
        document.getElementById("upload-model").disabled = true;
        document.getElementById("logout-btn").style.display = "none";
      }
    }

    // LOGIN or SIGNUP (WORKS)
    document.getElementById("login-btn").onclick = async () => {
      const email = document.getElementById("email").value;
      const password = document.getElementById("password").value;
      if (!email || !password) return alert("Enter email and password");

      const { data, error } = await supabaseClient.auth.signInWithPassword({ email, password });
      if (error && error.message.includes("Invalid login")) {
        await supabaseClient.auth.signUp({ email, password });
        alert("Account created. Check your email for confirmation.");
      } else if (data.user) {
        alert("Logged in successfully.");
      }
      await checkUser();
    };

    // LOGOUT (WORKS)
    document.getElementById("logout-btn").onclick = async () => {
      await supabaseClient.auth.signOut();
      document.getElementById("model-select").innerHTML = '<option disabled selected value="">SELECT A MODEL</option>';
      // Clear the current model from the viewer
      if (currentScene) currentScene.dispose();
      currentScene = await createScene(engine, canvas);
      await setupXR(currentScene);
      engine.runRenderLoop(() => currentScene.render());
      await checkUser();
    };

    // LOAD USER'S MODELS (WORKS)
    async function loadModelList(user) {
      const path = `${user.id}`;
      const { data, error } = await supabaseClient.storage.from(BUCKET).list(path, { limit: 100 });
      const select = document.getElementById("model-select");
      select.innerHTML = '<option disabled selected value="">SELECT A MODEL</option>';
      if (error) return console.error(error);

      data.forEach(item => {
        if (!item.name.match(/\.(glb|gltf|obj|fbx)$/i)) return;
        const opt = document.createElement("option");
        opt.value = item.name;
        opt.textContent = item.name.replace(/\.[^/.]+$/, "");
        select.appendChild(opt);
      });
    }

    // UPLOAD MODEL (WORKS)
    document.getElementById("upload-model").onclick = async () => {
      const { data: { user } } = await supabaseClient.auth.getUser();
      if (!user) return alert("Please login first.");

      const input = document.createElement("input");
      input.type = "file";
      input.accept = ".glb,.gltf,.obj,.fbx";
      input.onchange = async (e) => {
        const file = e.target.files[0];
        if (!file) return;

        const path = `${user.id}/${file.name}`;
        const { error } = await supabaseClient.storage.from(BUCKET).upload(path, file, { upsert: true });
        if (error) return alert("Upload failed: " + error.message);
        alert(`âœ… Uploaded ${file.name}`);
        await loadModelList(user);
      };
      input.click();
    };

    // SELECT MODEL TO LOAD (WORKS)
    document.getElementById("model-select").onchange = async (e) => {
      const filename = e.target.value;
      const { data: { user } } = await supabaseClient.auth.getUser();
      const modelUrl = `${SUPABASE_URL}/storage/v1/object/public/${BUCKET}/${user.id}/${filename}`;
      console.log("Loading model from:", modelUrl); // optional debug line
      if (currentScene) currentScene.dispose();
      currentScene = await createScene(engine, canvas, modelUrl);
      await setupXR(currentScene);
      engine.runRenderLoop(() => currentScene.render());
    };

    // ==============================
    //  MAIN INITIALIZATION
    // ==============================
    (async function main() {
      engine = new BABYLON.Engine(canvas, true);
      currentScene = await createScene(engine, canvas);
      await setupXR(currentScene);
      await checkUser();
      engine.runRenderLoop(() => currentScene.render());
      window.addEventListener("resize", () => engine.resize());
    })();
  </script>
</body>
</html>
